<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Puhao</title>
    <link>http://blog.puhao.me</link>
    <pubDate>2013-08-31 08:34:57 +0800</pubDate>
    <item>
      <title>Raspberry Pi下使用MongoDB</title>
      <link>http://blog.puhao.me/技术/Raspberry-Pi%E4%B8%8B%E4%BD%BF%E7%94%A8MongoDB/</link>
      <pubDate>2013-08-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;其实我更想把标题改为Raspberry Pi下折腾MongoDB。在开始折腾前，先介绍一个linux下的工具。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装准备&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在很多场景下，我都是都是SSH登录到Linux主机进行操作的，而不是直接在Linux主机上面通过键盘操作。一旦我们断开连接，如果任务没有执行完，那这个我们在这个SSH下发起的任务都会被终止掉，这个时候我们借助screen可以很好的帮我们把这个问题解决掉。关于screen，推荐阅读下&lt;a href=&#34;http://www.ibm.com/developerworks/cn/linux/l-cn-screen/&#34;&gt;《Linux技巧：使用screen管理你的远程会话》&lt;/a&gt;,详细介绍了为什么会关闭，到怎么使用screen。&lt;br /&gt;&#xA;Raspberry Pi官方提供的镜像下面没有自带screen，因此需要我们先安装下。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install screen&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;安装MongoDB&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于没有官方镜像提供，我们选择以源码方式安装。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;相关工具安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential libboost-filesystem-dev libboost-program-options-dev libboost-system-dev libboost-thread-dev scons libboost-all-dev git&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;获取源代码&lt;br /&gt;&#xA;MongoDB的源代码是基于x86机器的little endian的，Raspberry Pi的CPU是基于ARM的big endian，在github上面有big endian的&lt;a href=&#34;https://github.com/skrabban/mongo-nonx86&#34;&gt;nonx86版本&lt;/a&gt;提供。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/skrabban/mongo-nonx86&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;编译安装&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果是256m内存版本的Raspberry Pi，则编译安装的时候会出错，显示内存不足。因此还需要修改swap配置。修改&lt;code&gt;/etc/dphys-swapfile&lt;/code&gt;，把&lt;code&gt;CONF_SWAPSIZE&lt;/code&gt; 改成200。由于编译安装时间很长，需要几个小时，这个时候就可以借助screen了，命令输入完后做其他事情去好了，等待完成。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd mongo-nonx86&#xA;sudo scons&#xA;sudo scons --prefix=/opt/mongo install&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;配置MongoDB&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装完MongoDB后，简单配置就可以使用MongoDB了，建议把MongoDB作为系统服务的一部分。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;设置工作目录&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;增加用户&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; sudo adduser mongodb &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建日志目录&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mkdir /var/log/mongodb/&#xA;sudo chown mongodb /var/log/mongodb/&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建数据库目录&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mkdir /var/lib/mongodb&#xA;sudo chown mongodb /var/lib/mongodb &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;增加系统服务&lt;/p&gt;&#xA;&#xA;&lt;p&gt;源代码里面已经有系统服务的配置脚本了，不需要我们自己来写了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo cp debian/init.d /etc/init.d/mongod&#xA;sudo cp debian/mongodb.conf /etc/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改下系统服务脚本&lt;code&gt;/etc/ini.d/mongod&lt;/code&gt;里面50行，把&lt;code&gt;DAMEON&lt;/code&gt;设置为&lt;code&gt;/opt/mongo/bin/mongod&lt;/code&gt;,或者我们也可以不修改文件，直接建立个软连接。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo ln -s /opt/mongo/bin/mongod /usr/bin/mongod&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用chkconfig 增加系统服务，Raspberry Pi没有自带，需先安装下。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install chkconfig&#xA;sudo chkconfig --add mongod&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;使用MongoDB&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Raspberry Pi下面只能使用32位版本的MongoDB。32位版本的MongoDB有个限制就是最多处理2G的数据。另外，32位版本的MongoDB启动的时候，默认操作journal是不开启的，如果意外关闭MongoDB，则再次启动前需要进行repair修复。如果想避免这种情况，可以修改启动脚本，将journal开启，这样由于journal的开启占用总的数据，32位的MongoDB能处理的数据还要再下降一些。随着数据的增多，我遇到过在导出数据的时候出错，查看log文件发现是内存不够，建议更换到64位版本的MongoDB。&lt;br /&gt;&#xA;可以使用asyn，share等方式配置MongoDB来同步数据。如果想到Raspberry Pi里面的数据导入到其他服务器，除了前面的方法外，还可以直接使用 mongodump导出数据，然后 mongorestore来完成了数据的迁移。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>8月30日PAT考试</title>
      <link>http://blog.puhao.me/算法/8%E6%9C%8830%E6%97%A5PAT%E8%80%83%E8%AF%95/</link>
      <pubDate>2013-08-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;作为一名无证程序员，在即将找工作的情况下，我当然也随大流准备考个证，告别无证程序员生涯。然后现实生活无情的打击了我。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;请无视这段吐槽，直接看下一段解答&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://pat.zju.edu.cn/&#34;&gt;PAT&lt;/a&gt;考试是我们学校学院搞起的程序能力测试。我在报名缴费情况下，信心满满的第一次踏上了这样的考试，结果铩羽而归。考试用的计算机只有windows系统，没有linux，然后windows下面没有gcc，只有VS给你调试用。平常习惯了在sublime里面写代码，gcc的完美融合，让我用的十分顺手。我完全没有用过VS啊，VC6.0的时候还是会建立个consle工程的，然后VS里面最后貌似是成功创建出了工程，然后把sublime里面写的代码粘贴过去，各种报错，非常奇怪，然后我就放弃了，渣渣程序员，非法调试的话，做不到一次性成功啊。我猜测估计是文件编码不一样造成了这种奇怪的错误。然后就坐在那儿做题吧，考试肯定是0分了，尝试了几次提交，编译错误，然后根据错误信息再来改代码，太蛋疼了，还是放弃了，果断丢人的0分啊！没经验，too young，too simple, alway naive&lt;br /&gt;&#xA;回到实验室，在自己的MBP上面重新写了遍代码，但是OJ已经关闭了，不能测试最后写的程序。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;题目分析解答&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这次做的&lt;a href=&#34;http://pat.zju.edu.cn/contests/pat-a-101-105-2-2013-08-30&#34;&gt;题目&lt;/a&gt;。&lt;br /&gt;&#xA;&lt;a href=&#34;https://github.com/Puhao/PAT/tree/master/PAT(A)101-105-2-2013-08-30&#34;&gt;题目解答&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a href=&#34;http://pat.zju.edu.cn/contests/pat-a-101-105-2-2013-08-30/A&#34;&gt;Dating&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;主要是使用下STL的string，然后找到第一次相等，第二次相等的，然后控制输出格式。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void dating(string a,string b,string c,string d)&#xA;{&#xA;    char FstLet,SecLet;&#xA;    int count = 0;&#xA;    for(int i=0;i&amp;lt;a.size();i++)&#xA;    {&#xA;        if ((a[i] == b[i]) &amp;amp;&amp;amp; (isupper(a[i])))&#xA;        {&#xA;            if (count == 0)&#xA;            {&#xA;                count = 1;&#xA;                FstLet = a[i];&#xA;            }&#xA;            if (count == 1)&#xA;            {&#xA;                count = 2;&#xA;                SecLet = a[i];&#xA;            }&#xA;        }&#xA;    }&#xA;    string Week[] = {&amp;quot;MON&amp;quot;, &amp;quot;TUE&amp;quot;, &amp;quot;WED&amp;quot;, &amp;quot;THU&amp;quot;, &amp;quot;FRI&amp;quot;,&amp;quot;SAT&amp;quot;,&amp;quot;SUN&amp;quot;};&#xA;    int hour,minu;&#xA;    if (isdigit(SecLet))&#xA;        hour = SecLet - &#39;0&#39;;&#xA;    else&#xA;        hour = SecLet - &#39;A&#39; + 10;&#xA;    count = 0;&#xA;    for(int i=0;i&amp;lt;c.size();i++)&#xA;    {&#xA;        if ( (c[i] == d[i]) &amp;amp;&amp;amp; (isalpha(c[i])) )&#xA;        {&#xA;            if (count == 0)&#xA;            {&#xA;                count = 1;&#xA;                minu = i;&#xA;            }&#xA;        }&#xA;&#xA;    }&#xA;    cout.fill(&#39;0&#39;);&#xA;    cout &amp;lt;&amp;lt; Week[FstLet - &#39;A&#39;] &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; setw(2) &amp;lt;&amp;lt; hour &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; setw(2) &amp;lt;&amp;lt; minu &amp;lt;&amp;lt; endl;&#xA;    return;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a href=&#34;http://pat.zju.edu.cn/contests/pat-a-101-105-2-2013-08-30/B&#34;&gt;Talent and Virtue&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一次读入学生信息，然后归类把不同学生放到不同的vector里面，然后单独sort下，然后输出。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct student&#xA;{&#xA;    long long int id;&#xA;    int virtue;&#xA;    int talent;&#xA;    student(long long int i,int v,int t):id(i),virtue(v),talent(t){}&#xA;    /* data */&#xA;};&#xA;&#xA;bool compare_less(const student &amp;amp;a,const student &amp;amp;b)&#xA;{&#xA;    return ((a.virtue + a.talent) &amp;gt; (b.virtue + b.talent));&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    int num,low,high;&#xA;    cin &amp;gt;&amp;gt; num &amp;gt;&amp;gt; low &amp;gt;&amp;gt; high;&#xA;    int count = 0;&#xA;    long long int id;&#xA;    int virtue;&#xA;    int talent;&#xA;    vector&amp;lt;student&amp;gt; stu[4];&#xA;    while(num--)&#xA;    {&#xA;        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; virtue &amp;gt;&amp;gt; talent;&#xA;        if ((virtue &amp;lt; low) || (talent &amp;lt; low))&#xA;        {&#xA;            continue;&#xA;        }&#xA;        count++;&#xA;        if ((virtue &amp;gt;= high) &amp;amp;&amp;amp; (talent &amp;gt;= high))&#xA;        {&#xA;            stu[0].push_back(student(id,virtue,talent));&#xA;        }&#xA;        else if ((virtue &amp;gt;= high) &amp;amp;&amp;amp; (talent &amp;lt; high))&#xA;        {&#xA;            stu[1].push_back(student(id,virtue,talent));&#xA;        }&#xA;        else if ((virtue &amp;lt; high) &amp;amp;&amp;amp; (talent &amp;lt; high) &amp;amp;&amp;amp; (virtue &amp;gt;= talent))&#xA;        {&#xA;            stu[2].push_back(student(id,virtue,talent));&#xA;        }&#xA;        else&#xA;        {&#xA;            stu[3].push_back(student(id,virtue,talent));&#xA;        }       &#xA;    }&#xA;    for(int i=0;i&amp;lt;4;i++)&#xA;    {&#xA;        sort(stu[i].begin(), stu[i].end(),compare_less);&#xA;    }&#xA;    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;&#xA;    for(int i=0;i&amp;lt;4;i++)&#xA;    {&#xA;        vector&amp;lt;student&amp;gt;::const_iterator it;&#xA;        for(it = stu[i].begin(); it != stu[i].end(); it++)&#xA;        {&#xA;            cout &amp;lt;&amp;lt; it-&amp;gt;id &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;virtue &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; it-&amp;gt;talent &amp;lt;&amp;lt; endl;&#xA;        }&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a href=&#34;http://pat.zju.edu.cn/contests/pat-a-101-105-2-2013-08-30/C&#34;&gt;Set Similarity&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;用STL的set，然后把所有的输入维护成一个元素为set的vector.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;double set_similarity(set&amp;lt;int&amp;gt; a,set&amp;lt;int&amp;gt; b)&#xA;{&#xA;    double pub = 0;&#xA;    set&amp;lt;int&amp;gt;::const_iterator it;&#xA;    for (it=a.begin();it!=a.end();it++)&#xA;    {&#xA;        if(b.count(*it))&#xA;            pub++;&#xA;    }&#xA;    return 100 * pub / (a.size() + b.size() - pub);&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    vector&amp;lt;set&amp;lt;int&amp;gt; &amp;gt; AllSet;&#xA;    set&amp;lt;int&amp;gt; TmpSet;&#xA;    int num,cnt;&#xA;    cin &amp;gt;&amp;gt; num;&#xA;    int index = 0;&#xA;    int tmp;&#xA;    while(index != num)&#xA;    {&#xA;        TmpSet.clear();&#xA;        cin &amp;gt;&amp;gt; cnt;&#xA;        while (cnt--)&#xA;        {&#xA;            cin &amp;gt;&amp;gt; tmp;&#xA;            TmpSet.insert(tmp);&#xA;        }&#xA;        AllSet.push_back(TmpSet);&#xA;        index++;&#xA;    }&#xA;    cin &amp;gt;&amp;gt; num;&#xA;    int one,two;&#xA;    while(num--)&#xA;    {&#xA;        cin &amp;gt;&amp;gt; one &amp;gt;&amp;gt; two;&#xA;        double resutl = set_similarity(AllSet[one-1],AllSet[two-1]);&#xA;        cout &amp;lt;&amp;lt; setiosflags(ios::fixed)&amp;lt;&amp;lt; setprecision(1) &amp;lt;&amp;lt;resutl &amp;lt;&amp;lt; &amp;quot;%&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a href=&#34;http://pat.zju.edu.cn/contests/pat-a-101-105-2-2013-08-30/D&#34;&gt;Complete Binary Search Tree&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;刚看到这道题目的时候，第一反应就是像最大堆那样建堆，不同的是这个堆是个二叉查找堆，然后每次进行堆元素的插入，但思考下发现这个插入新元素，堆的交换并不像最大堆那样简单。&#xA;后来想到，其实这棵树的中序遍历就是一个排列好的数组，因此利用这个性质，我们把元素从小到大，依次填入CBST这个数组中。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Node&#xA;{&#xA;    int val;&#xA;    Node *left;&#xA;    Node *right;&#xA;    Node(int v):val(v){}&#xA;    /* data */&#xA;};&#xA;&#xA;void BuildArray(int index,int &amp;amp;pos,vector&amp;lt;int&amp;gt; &amp;amp;v,vector&amp;lt;int&amp;gt; &amp;amp;cbst,int m)&#xA;{&#xA;    if (index &amp;gt;=m)&#xA;        return;&#xA;    //先填左子树，然后填自己，最后填右子树&#xA;    BuildArray(index*2 + 1,pos,v,cbst,m);&#xA;    cbst[index] = v[pos++];&#xA;    BuildArray(index*2 + 2,pos,v,cbst,m);&#xA;    return;&#xA;}&#xA;&#xA;&#xA;int main()&#xA;{&#xA;    int num;&#xA;    cin &amp;gt;&amp;gt; num;&#xA;    int count = num;&#xA;    std::vector&amp;lt;int&amp;gt; v;&#xA;    vector&amp;lt;int&amp;gt; cbst(num,0);&#xA;    int tmp;&#xA;    while(count--)&#xA;    {&#xA;        cin &amp;gt;&amp;gt; tmp;&#xA;        v.push_back(tmp);&#xA;    }&#xA;    sort(v.begin(), v.end());&#xA;    int pos = 0;&#xA;    BuildArray(0,pos,v,cbst,num);&#xA;    for(int i=0;i&amp;lt;num;i++)&#xA;    {&#xA;        cout &amp;lt;&amp;lt; cbst[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;&#xA;    }&#xA;    cout &amp;lt;&amp;lt; endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Word Ladder</title>
      <link>http://blog.puhao.me/算法/Word-Ladder/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;LeetCode上面有两道关于单词变换的题目。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Word Ladder&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Only one letter can be changed at a time&#xA;Each intermediate word must exist in the dictionary&#xA;For example,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given:&#xA;start = &amp;ldquo;hit&amp;rdquo;&lt;br /&gt;&#xA;end = &amp;ldquo;cog&amp;rdquo;&lt;br /&gt;&#xA;dict = [&amp;ldquo;hot&amp;rdquo;,&amp;ldquo;dot&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;lot&amp;rdquo;,&amp;ldquo;log&amp;rdquo;]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As one shortest transformation is &amp;ldquo;hit&amp;rdquo; -&amp;gt; &amp;ldquo;hot&amp;rdquo; -&amp;gt; &amp;ldquo;dot&amp;rdquo; -&amp;gt; &amp;ldquo;dog&amp;rdquo; -&amp;gt; &amp;ldquo;cog&amp;rdquo;,&#xA;return its length 5.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Return 0 if there is no such transformation sequence.&lt;br /&gt;&#xA;All words have the same length.&lt;br /&gt;&#xA;All words contain only lowercase alphabetic characters.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;由于需要找到最短的变换路径，因此使用BFS查找，相同深度的在同一轮遍历每个单词进行检查是否有下一个跳转的路径，因此从单词首位开始到末位，每次只能变换一个位置，如果变换的单词在dict中，则加入队列，供下一轮遍历查找。当找到最终跳转单词的时候，返回当前遍历的深度即可。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int ladder(string start, string end, set&amp;lt;string&amp;gt; &amp;amp;dict)&#xA;{&#xA;    if (start == end)&#xA;        return 1;&#xA;    int step = 1;&#xA;    queue&amp;lt;string&amp;gt; q;&#xA;    q.push(start);&#xA;    while(q.size()) //BFS队列有元素就继续查找&#xA;    {&#xA;        step++;&#xA;        int len = q.size();&#xA;        while(len--)    //相同深度的节点数目&#xA;        {&#xA;            string check = q.front();&#xA;            for(int i = 0; i&amp;lt;check.size(); i++)&#xA;            {&#xA;                char tmp = check[i];&#xA;                for(char j=&#39;a&#39;; j&amp;lt;=&#39;z&#39;; j++)&#xA;                {&#xA;                    check[i] = j;&#xA;                    if (check == end)&#xA;                        return step;&#xA;                    if (dict.count(check))&#xA;                    {&#xA;                        q.push(check);  &#xA;                        dict.erase(check);&#xA;                    }&#xA;        &#xA;                }&#xA;                check[i] = tmp;&#xA;            }&#xA;            q.pop();&#xA;        }&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;Word Ladder 2&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Only one letter can be changed at a time&#xA;Each intermediate word must exist in the dictionary&#xA;For example,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given:&lt;br /&gt;&#xA;start = &amp;ldquo;hit&amp;rdquo;&lt;br /&gt;&#xA;end = &amp;ldquo;cog&amp;rdquo;&lt;br /&gt;&#xA;dict = [&amp;ldquo;hot&amp;rdquo;,&amp;ldquo;dot&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;lot&amp;rdquo;,&amp;ldquo;log&amp;rdquo;]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Return&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;[&lt;br /&gt;&#xA;   [&amp;ldquo;hit&amp;rdquo;,&amp;ldquo;hot&amp;rdquo;,&amp;ldquo;dot&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;cog&amp;rdquo;],&lt;br /&gt;&#xA;   [&amp;ldquo;hit&amp;rdquo;,&amp;ldquo;hot&amp;rdquo;,&amp;ldquo;lot&amp;rdquo;,&amp;ldquo;log&amp;rdquo;,&amp;ldquo;cog&amp;rdquo;]&lt;br /&gt;&#xA; ]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Note:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All words have the same length.&lt;br /&gt;&#xA;All words contain only lowercase alphabetic characters.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这个时候，我们需要多维护一个目录，就是每个单词的前序列表，这个单词可以由哪几个单词到达，每个单词的前序列表其实是一个set（没有重复元素），这里有一个小陷阱，那就是每一轮遍历的时候，找到dict中有的元素，不能马上删除dict中的元素，要等到这轮遍历完毕，因为有可能还有其他单词能够到达这个单词，同时这个单词也不能马上放入队列供下一轮查找，首先要检查这一轮的时候是否已经放置过这个单词，防止下一轮遍历检查的单词有重复。当我们通过BFS查找到变化序列的时候，根据每个单词的前序单词，使用DFS来输出所有可到达路径。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//查看每个单词的前序序列&#xA;void PrintPreList(map&amp;lt;string,vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;LadPre)&#xA;{&#xA;    map&amp;lt;string,vector&amp;lt;string&amp;gt; &amp;gt;::const_iterator  it;&#xA;    vector&amp;lt;string&amp;gt;::const_iterator vt_it;&#xA;    for (it = LadPre.begin();it != LadPre.end();it++)&#xA;    {&#xA;        cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;quot;:&amp;quot;;&#xA;        for(vt_it=(it-&amp;gt;second).begin();vt_it &amp;lt; (it-&amp;gt;second).end(); vt_it++)&#xA;        {&#xA;            cout &amp;lt;&amp;lt; *vt_it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;&#xA;        }&#xA;        cout &amp;lt;&amp;lt; endl;&#xA;    }&#xA;    return;&#xA;}&#xA;&#xA;//根据前序序列，通过DFS找到所有路径&#xA;void FindPath(map&amp;lt;string,vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;LadPre, vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;LadRoad,string start,string end,vector&amp;lt;string&amp;gt; &amp;amp;OneRoad)&#xA;{&#xA;    if (start == end)&#xA;    {&#xA;        OneRoad.push_back(start);&#xA;        reverse(OneRoad.begin(), OneRoad.end());&#xA;        LadRoad.push_back(OneRoad);&#xA;        reverse(OneRoad.begin(), OneRoad.end());&#xA;        OneRoad.pop_back();&#xA;        return;&#xA;    }&#xA;    OneRoad.push_back(end);&#xA;    vector&amp;lt;string&amp;gt;::const_iterator it;&#xA;    vector&amp;lt;string&amp;gt; list = LadPre[end];&#xA;    for (it=list.begin(); it &amp;lt; list.end(); it++)&#xA;    {&#xA;        FindPath(LadPre,LadRoad,start,*it,OneRoad);&#xA;    }&#xA;    OneRoad.pop_back();&#xA;    return;&#xA;}&#xA;&#xA;//BFS查找最少变化路径&#xA;vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; findLadders(string start, string end, set&amp;lt;string&amp;gt; &amp;amp;dict) &#xA;{&#xA;        // Start typing your C/C++ solution below&#xA;        // DO NOT write int main() function&#xA;    vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; LadRoad;&#xA;    vector&amp;lt;string&amp;gt; OneRoad;&#xA;    map&amp;lt;string,vector&amp;lt;string&amp;gt; &amp;gt;LadPre;  //记录每个单词，在相同最少跳跃次数下可以由哪几个单词跳转来到&#xA;    if (start == end)&#xA;        return LadRoad;&#xA;&#xA;    queue&amp;lt;string&amp;gt;   LadQue;&#xA;    queue&amp;lt;string&amp;gt;   DelQue;&#xA;    set&amp;lt;string&amp;gt; RoundSet;   //确保每轮queue入队的元素没有重复的&#xA;&#xA;    LadQue.push(start);&#xA;    //有一个小陷阱，如果开始的元素已经在dict里面，在变化检索的时候会产生重复元素&#xA;    //if(dict.count(start))&#xA;    //  dict.erase(start);&#xA;    bool FindEnd = false;&#xA;    while(!LadQue.empty())&#xA;    {&#xA;        int length = LadQue.size();&#xA;        while(length--)&#xA;        {&#xA;            string check = LadQue.front();&#xA;            string PreWord = check;&#xA;            for(int i=0; i&amp;lt;check.size(); i++)&#xA;            {&#xA;                char tmp = check[i];    //每次变化一位&#xA;                for(char j=&#39;a&#39;; j&amp;lt;=&#39;z&#39;; j++)&#xA;                {&#xA;                    check[i] = j;&#xA;                    if (check == end)&#xA;                    {&#xA;                        LadPre[check].push_back(PreWord);&#xA;                        FindEnd = true;                     &#xA;                    }&#xA;                    else if (dict.count(check)) //if the string is in dict&#xA;                    {&#xA;                        if (!RoundSet.count(check))&#xA;                        {&#xA;                            RoundSet.insert(check);&#xA;                            DelQue.push(check);     //这个深度的全部检查完之后，才能从dict中删除&#xA;                            LadQue.push(check);&#xA;                        }&#xA;                        LadPre[check].push_back(PreWord);&#xA;                    }&#xA;                }&#xA;                check[i] = tmp;&#xA;            }&#xA;            LadQue.pop();   //单词检查完毕,出队&#xA;        }&#xA;        RoundSet.clear();&#xA;&#xA;        if (FindEnd)    //在这个深度的时候找到了最终跳转结果&#xA;        {&#xA;            //PrintPreList(LadPre);&#xA;            FindPath(LadPre,LadRoad,start,end,OneRoad);&#xA;            return LadRoad;&#xA;        }&#xA;&#xA;        while(!DelQue.empty())&#xA;        {&#xA;            string tmp = DelQue.front();&#xA;            dict.erase(tmp);&#xA;            DelQue.pop();&#xA;        }&#xA;    }&#xA;    return LadRoad;    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Puhao/leetcode&#34;&gt;点击我&lt;/a&gt;查看更多LeetCode题目解答。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>NetFPGA</title>
      <link>http://blog.puhao.me/FPGA/NetFPGA/</link>
      <pubDate>2013-08-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自己是在大三暑假的时候接触到的&lt;a href=&#34;http://netfpga.org/&#34;&gt;NetFPGA&lt;/a&gt;，那个时候正好是因为全国电子设计大赛信息安全邀请赛FPGA组使用的平台是NetFPGA，所以接触到了这个平台。&#xA;我后来在OpenHW社区连载了&lt;a href=&#34;http://www.openhw.org/sain_1989/blog/10-09/195099_f3e5f.html&#34;&gt;NetFPGA开发指南&lt;/a&gt; ,最后完成了一份&lt;a href=&#34;http://www.openhw.org/blog/link2url.php?link=%2Fbbs%2Ffile_94193.html&#34;&gt;NetFPGA开发指南1.1.pdf&lt;/a&gt;的文档。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那是自己用Verilog写的第一个比较大的project，自己Verilog的代码能力就是在那个项目里面得到的进步的。通过阅读别人写的优秀代码，的确能够进步很多。回头再看当初写的那份文档，其实更像是一份啰嗦版的step by step。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为那次比赛，我改变了很多，也许变的所谓的成熟了吧。当我读研之后，我也再没有接触过NetFPGA平台，不过通过这个平台让自己Verilog设计和网络二三层方面的知识得到了相当大的进步。也通过比赛，知道很多事情没必要看的太重，take it easy，just do it for fun。这样的态度改变在我的研究生生涯中得到了最好的体现，我折腾了各种有趣好玩的东西，以兴趣为导向玩的很开心，当自己开始要找工作，准备告别研究生生涯的这个时候，回头看，觉得自己过去的一段经历是那么的有趣，好玩，也因为自己对职业方向的规划，督促着自己不断学习着新的知识。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;认真投入去做一件事情，能够让自己受益很久，至少目前我是这样的。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>FPGA图像处理</title>
      <link>http://blog.puhao.me/FPGA/FPGA%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</link>
      <pubDate>2013-08-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;突然想写篇这方面的blog，主要是想着把N年前写的blog也汇总到这里来。以前曾经写过&lt;a href=&#34;http://www.openhw.org/sain_1989/blog/12-05/279347_f3591.html&#34;&gt;FPGA视频采集&lt;/a&gt;和&lt;a href=&#34;http://www.openhw.org/sain_1989/blog/12-07/281798_e0f79.html#articletop&#34;&gt;FPGA存储控制器&lt;/a&gt;,这正好涉及到了视频图像的采集，存储，应该把处理的尾巴给续上去。这儿不涉及到具体的技术细节，只是谈下整个设计流程，更像一篇科普文章。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;图像获取&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.openhw.org/sain_1989/blog/12-05/279347_f3591.html&#34;&gt;FPGA视频采集&lt;/a&gt;里面主要是提了一下如何获取PAL视频源的问题，通过AD转换芯片和时序逻辑组合获取原始像素。我们也可以直接从摄像头获取视频图像，以OV7670为例。&lt;br /&gt;&#xA;这是一款非常主流的摄像头，被用于很多嵌入式设备中。它支持标准的SCCB接口，兼容I2C接口，而且提供丰富的图像格式输出，包括RawRGB,RGB(GRB4:2:2,RGB565/&lt;sup&gt;555&lt;/sup&gt;&amp;frasl;&lt;sub&gt;444&lt;/sub&gt;),YUV(4:2:2)和YCbCr(4:2:2)。&lt;br /&gt;&#xA;我们只需通过接口完成对芯片的配置，然后按照接口时序完成对摄像头输出的数据解析。根据我们后面的算法是基于YUV的或者RGB的来控制这款摄像头的视频输出格式，直接存储，方便后面的视频处理。&lt;br /&gt;&#xA;关于如何读取这款芯片的输出图像，可以去&lt;a href=&#34;http://www.amobbs.com/forum.php&#34;&gt;阿莫电子论坛&lt;/a&gt;找下，里面有很多网友共享的实例。不过很多通过MCU来获取的（网站里也有FPGA获取的实例），考虑到MCU处理速度慢的缘故，有些模块还会加个FIFO来做帮助，用FPGA就可以直接获取了，不需要FIFO的帮助。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;图像存储&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.openhw.org/sain_1989/blog/12-07/281798_e0f79.html#articletop&#34;&gt;FPGA存储控制器&lt;/a&gt;介绍了Xilinx的MCB的使用。因为芯片出来的图像已经变成了顺序的的了，考虑到后面的图像处理算法，我们需要把一帧图像缓存下来，一般情况下我们会缓存好几帧图像。存储器我们可以考虑SRAM,SDRAM，DDR2等存储芯片。综合到图像的大小，存取速率问题，DDR2或者DDR3存储芯片是我们的首选，但是针对不同的存储芯片，在我们设计FIFO村读取的时候，还需要解决一个芯片控制器的问题。一种方法是去&lt;a href=&#34;http://opencores.org/&#34;&gt;OpenCores&lt;/a&gt;上找开源的IP Core作为我们的存储控制器，另外一种方法就是使用FPGA芯片厂商给我们提供的硬核控制器。&lt;br /&gt;&#xA;以Xilinx的Spartan系列FPGA为例，它给用户提供了MCB这个硬核，存储控制模块，我们只需按照这个IP的时序就可以很轻松的完成视频图像的存储与读取。用硬核的一个好处就是不占用FPGA提供给我们的逻辑门，而且在速度上面也有很大的优势，而且很好的支持&lt;a href=&#34;http://baike.baidu.com/view/2375625.htm&#34;&gt;AXI&lt;/a&gt;总线。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;图像处理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;看到这儿，一般做视频图像处理的人会觉得这也太麻烦了吧？我openCV里面直接一行代码就可以读取一帧图像了，到你这里怎么麻烦了？&#xA;这里以使用USB摄像头为例，说明下图像处理的流程。我们的摄像头处理芯片通过感光元件(感光元件还有CMOS,CCD之分)获取了图像，并且通过USB输送PC机。USB的全称就是Universal Serial Bus，一种计算机总线，而我们的摄像头又有OS下的USB驱动，OS又完成了一次对图像的缓存，接口封装，因此用户软件只需通过OS接口就能直接读取图像了，把前面做的各种繁琐的步骤全部完成了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个时候我们需要注意的是，以我们写的C++图像处理算法为例。计算机是如何处理执行我们的算法的？学过计算机组成的都知道，编译器将我们的代码编译出了汇编语言。计算机读取汇编程序，完成取值，译码，执行操作，一条条执行完我们的代码，又转换回了0101格式。从这个流程大家就知道了CPU做图像处理慢的劣势了，因此PC上又诞生了GPU，而在嵌入式领域有了DSP等专用处理芯片，两者的原理上是差不多的。&lt;br /&gt;&#xA;FPGA有一大天生的优势就是能够集成软件的易用与硬件的高效，因此FPGA也被人越来越多的运用到了图像处理领域。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以Verilog HDL这种用于FPGA的硬件语言为例，hardware language和software language的最大区别在于:前者是一种并行的语言，后者是一种串行的语言。在软件界，并行计算一直是研究的热点，如何让程序并行处理，而硬件语言天生就是并行的。在写Verilog的时候，我们脑子里实际想的就是一个个module，每个module都对应着一个个实际的电路，当我们有些算法需要串行执行的时候，这个时候一般会考虑设计一个FSM来完成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/FPGA图像处理/RTL.jpg&#34; alt=&#34;RTL图&#34; width=&#34;600&#34; height=&#34;400&#34;&gt;&lt;br /&gt;&#xA;Verilog对应的RTL图&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此设计基于FPGA的图像处理算法的时候，我们就是直接在操作一个个像素点，而且是同时的，而不是像传统的做法那样还要靠CPU的指令翻译顺序执行。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;软件的好处就是有一个个库可以直接让我们使用，让我们在一个更高的抽象层来设计我们的算法，而且很多现场的库供我们使用，可以大大减少工作量，不用重复造一些没必要的轮子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以做一个简单的&lt;a href=&#34;http://baike.baidu.com/view/676368.htm&#34;&gt;sobel边缘检测&lt;/a&gt;算法为例，我们只需做一个简单的加减运算就可以了，但是在硬件电路里面我们拥有的只是原始的and，or操作，学过计算机组成的知道我们这个时候就需要设计一个加法器，乘法器了。做到这里我们就已经有些崩溃了，连这么基本的轮子我们都得重复造啊？这个时候就可以考虑下面介绍的几个工具。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Simulink HDL Coder&lt;/li&gt;&#xA;&lt;li&gt;Xilinx System Generator&lt;/li&gt;&#xA;&lt;li&gt;Altera DSP Builder&lt;/li&gt;&#xA;&lt;li&gt;Vivado&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;一些非IT领域的工程师，在做一些控制算法的时候，他们很喜欢使用Simulink来做控制算法，这种基于MBD的开发方法，大大节省了设计，验证的时间。一个个模块的重复使用，很好的仿真测试，这些对于软件工程师来说是最熟悉不过的东西了。&#xA;Simulink HDL Coder就是这么一个工具，我们还是可以在simulink里面设计算法，然后进行仿真，然后直接利用HDL Coder生成HDL代码。Xilinx和Altera两个厂家针对自己的FPGA芯片也推出了各自可以在simulink里面使用的MBD设计工具System Generator和DSP Builder。&lt;br /&gt;&#xA;我用过Xilinx的System Generator做过一个project。在project里面，有一些数学算法需要处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/FPGA图像处理/wave.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;br /&gt;&#xA;主要是几个简单的三角函数关系&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个时候我就直接使用了System Generator搭建了算法模型，一共有好几个System Generator算法模型，然后把生成的代码与其他Verilog代码整合到一块，有一点很讨厌的就是带上了System Generator生成代码的project，编译，布局布线耗费的时间特别长，让人难以接受，那个project从编译到最后生成bit需要花费4个小时，非常耗时。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于System Generator，我非常推荐一本书：&lt;a href=&#34;http://item.jd.com/10067534.html&#34;&gt;《多媒体处理FPGA实现&amp;ndash;System Generator篇》&lt;/a&gt;,书里面很详细的介绍了如何使用System Generator来搭建一些基本的图像处理算法，通过System Generator可以很容易搭建一个Sobel边缘检测算法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/FPGA图像处理/sobel.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;br /&gt;&#xA;书中的sobel边缘检测实例&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如今Xilinx推出了更加逆天的设计工具Vivado，它里面集成了一个叫做HLS的工具，可以让我们的C++图像处理代码直接变成HDL代码执行。&lt;br /&gt;&#xA;在2012的x-fest展会上，有人展示了一个基于xilinx的zynq做的一个愤怒的小鸟的边缘检测算法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XNDMxNTI1NTY4/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从演示视频看到，用FPGA可以很流畅的处理高清视频。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用System Generator或者HLS生成的模块，可以很好的集成到AXI总线上，因此我们可以很方便的设计一个SOPC系统，它就带有了一个专门的硬件加速处理模块。用硬件来做图像处理也是一个趋势，很多芯片厂商直接在芯片里面集成了一些常用的视频处理算法，比如人脸检测算法，这样的SOC就大大提高了视频处理的效率。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以YY这样一个场景，比如做汽车的道路偏移检测的（高档汽车带有这个功能），里面有一个很重要的事情就是边缘检测然后Hough变换检测直线，这么一个算法对于用C/C++代码来实现的话是个很简单的事情。但是汽车是在高速行进的，因此我们对于算法的处理速度有限制要求，这个时候我们就想到使用FPGA来做，因此想着使用Vivado来实现这个功能，这样我们就可以让普通汽车也带有这样的功能了。&lt;br /&gt;&#xA;&lt;img src=&#34;/assets/media/FPGA图像处理/hough.jpg&#34; alt=&#34;&#34; width=&#34;600&#34;&gt;&lt;br /&gt;&#xA;上面这张图是我开车时候道路图像比较理想情况拍下的，在matlab里面利用hough找到了车道边缘。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S现在做汽车周边的很多，有做道路偏移的，有做行人检测的，有做360°停车影像的，他们的商业模式都是想让普通车都拥有高档车才有的功能。有一次我在学校的阿波罗店里打牌，坐在我后面桌子的三个人就在那边讨论做这么一个事情，他们连商业计划什么都做好了，准备流片生产这样的SOC，或者销售licence。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用多说</title>
      <link>http://blog.puhao.me/吐槽/%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%AF%B4/</link>
      <pubDate>2013-08-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Github不亏为程序员的Facebook，早上我在gor提交了一个issue说可以考虑支持下友言，结果作者下午就回复了，并且增加了这个功能，然后正好有另外的开发者完成了多说的挂件，然后发生的故事就是这个blog的评论由多说来负责了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;多说使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;本来只注意到友言，但正好看到gor里面有人实现了一个多说的挂件，然后看了一下多说，发现蛮不错的，真的做到了评论社交化，而且把友言和加网整合到一起整合的很好，这完全就是一个评论的SNS啊。&lt;br /&gt;&#xA;接下来的问题就是comments里面的config.yml配置问题了，结果蛋疼了，多说也是靠一个short&lt;em&gt;name绑定的，问题是怎么申请获取这个short_name。&lt;br /&gt;&#xA;看来多说官网，发现是申请多说二级域名，然后就能获得short_name了。多说的官网还反复提到神马后台管理啊，就是找不到申请二级域名的地方，这不是坑爹嘛。&lt;br /&gt;&#xA;最终，在我不断的寻找点击后，终于找到了那个链接：&lt;/em&gt;&lt;a href=&#34;http://duoshuo.com/create-site/&#34;&gt;获取多说通用代码&lt;/a&gt;_&lt;br /&gt;&#xA;填写下申请内容，申请了puhaoblog.duoshuo.com，这样我的short_name就是puhaoblog，这样我再去配置下blog里面comment的config.yml，就搞定了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;layout : duoshuo&#xA;duoshuo :&#xA;  short_name : puhaoblog&#xA;livefyre :&#xA;  site_id : 123&#xA;intensedebate :&#xA;  account : 123abc&#xA;facebook :&#xA;  appid : 123&#xA;  num_posts: 5&#xA;  width: 580&#xA;  colorscheme: light&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;主要写前面三行就OK了，这样blog就能帅气的使用多说评论系统了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;社会化分工&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当然，我又要开始吹牛逼了，这两天折腾blog，把blog部署到github的pages上，然后又整合了多说这样social评论系统，blog看上去顿时高端洋气了许多，其实我TMD只是个组装工人，没有任何技术含量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以前看到一些blog下面的留言啊什么，总是觉得太烦，需要输入个邮箱啊什么的，当把这些写完，都木有动力给作者评价一句或者怎么了，原来基于评论的SNS如今已经做的这么棒了，觉得一般别人再造车子的时候，可以考虑多说这个轮子，这真的是一个很好的轮子。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在学校里，总是遇到什么大项目啊，863，973，核高基，老板还会忽悠你拥有了一个别人都没有的机会来做一个大的系统xxooxx吐槽点到为止，这个话题其实很有探讨价值的。我们看到别人把一个评论系统，这么一个不起眼的东西做好，做到极致。我们每次总想着新的方向啊，挖坑啊，其实完全可以把一件普通的事情做好，做完发现这也是一个不错的方向嘛。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;社会分工越来越细分，我们应该把握好一件细分领域的事情把它做到极致，而不是大家去重复做一些事情。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;刷机&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;今天还有一件事情让我对社会分工的感受很强烈&amp;ndash;刷机。&lt;br /&gt;&#xA;iphone用户才来不会有这样的需求（iphone售价高，因为里面有很大一部分是它的服务），但是一个android手机就要经历刷机三步曲：ROOT，recovery，ROM。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我已经N年没有干过刷机这种事情了，但是我觉得刷机界这个细分的市场也应该有它的领头羊了。ROM方面，MIUI已经是无可置疑的王者了，老罗的锤子ROM真在牛逼中成长，但是刷ROM前面的事情呢？哦，有个刷机助手，但是不幸的是我想刷的中兴U956不在支持范围，然后只能一步步自己来折腾。&lt;br /&gt;&#xA;当我刷好MIUI的时候，发现MIUI里面集成了很多服务，完全在模仿IOS里面的服务，它以ROM为起点，前后通吃。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当然搞移动互联的一天到晚喊着要抢着用户入口，ROM是个入口，手机助手是一个入口，APP是一个入口，就好像曾经的OS，浏览器，网站。我只是好奇360什么时候出ROM啊?不然MIUI越做越好，大家都不会再去装个360手机助手了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当我刷机完成，装好MIUI，然后再装导航，这样一部手机最终才会交付给用户&amp;ndash;我老爸。于是一部廉价的基于MTK方案的国产机器，经过我的集成包装，对于像我老爸这样的用户，成了一部可以媲美iphone的手机了，我&amp;rdquo;卖&amp;rdquo;给我老爸的是服务。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Blog折腾</title>
      <link>http://blog.puhao.me/吐槽/Blog%E6%8A%98%E8%85%BE/</link>
      <pubDate>2013-08-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在程序界有一句话很流行,不要重复造轮子。哦，我不是来讨论&lt;a href=&#34;http://taosay.net/?p=575&#34;&gt;重复造轮子&lt;/a&gt;这件事情的。&lt;br /&gt;&#xA;昨天用gor生成了自己的blog，然后我折腾的本性又显示出来了，当然要添加点自己的玩意，随着折腾进行发现自己又陷入了程序员重复造轮子的话题。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;气象站数据&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;第一个想到的当然是我的&lt;a href=&#34;https://github.com/Puhao/ecomesh&#34;&gt;气象站&lt;/a&gt;数据问题。我现在的数据直接转发到了&lt;a href=&#34;http://www.yeelink.net/&#34;&gt;Yeelink&lt;/a&gt;，顺便发发&lt;a href=&#34;http://weibo.com/u/3551343502&#34;&gt;微博&lt;/a&gt;。&lt;a href=&#34;http://www.yeelink.net/devices/3762#&#34;&gt;平台曲线&lt;/a&gt;展示了我阳台最近的天气变化。&lt;br /&gt;&#xA;但是我想着在这个blog也能展示曲线，我想到的就是我本来用raspberry pi采集数据的存储到本地MySQL数据库的，自己只需再写个后台服务程序，然后前端用个JQuery的库，比如Highcharts,前端还能做个ajax数据交互，实时更新。&#xA;我看了&lt;a href=&#34;http://hugozhu.myalert.info/&#34;&gt;别人的做法&lt;/a&gt;（其实我更想用山寨这个词语，我最擅长的就是模仿，Orz),直接使用了第三方的物联网平台&amp;ndash;&lt;a href=&#34;https://xively.com/&#34;&gt;xively&lt;/a&gt;。&lt;br /&gt;&#xA;中国版的物联网开发平台相比之下，真的是模仿了它的外形，但是没有把其它一些辅助的功能做好。提供一个app-key，post接口让大家传数据，但是没有考虑到第三方网站的外链之类的。毕竟国内做物联网的平台的，boss更多是做嵌入式出身，身上少了些互联网基因。&lt;br /&gt;&#xA;我知道我不应该再造个轮子了，直接用别人的工具吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于我的气象站，等我把其它部件整完了，我专门写篇Blog来介绍下。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;评论，分享&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;原来gor里面集成了disqus，但是毕竟这个里面关联的账号啊都是twitter，facebook，天朝用户都是weibo啊，人人啊之类的账号，果然我就发现了中国版的disqus， &lt;a href=&#34;http://www.uyan.cc/&#34;&gt;友言&lt;/a&gt;。然后发现&lt;a href=&#34;http://www.jiathis.com/&#34;&gt;加网&lt;/a&gt;提供了我们最需要的一键分享功能，而且他们两个是一家公司的。&lt;br /&gt;&#xA;然后我看了下，自己是不是要学下go语言，然后gor里面折腾下，让这个功能支持？还是先在github里面提交了一个issue。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;主页改动&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当然首页风格也是需要改改的，非常好，gor使用了bootstrap这套框架，因此自己改动页面也非常方便。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;增加轮子&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;前面提到的xively，disqus，友言，加网，bootstrap这些东西都非常好用，只需要在HTML里面加入一些元素就实现了，这些轮子真的做到了组装方便，让我们这些没有技术含量的“系统集成商”非常喜欢。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;结尾吐槽&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;自己用人人这样的SNS，还有weibo，又搞这个blog干神马了？这不就是个重复造了个大轮子？其实我就是喜欢造轮子，一般人我不告诉他。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>记忆</title>
      <link>http://blog.puhao.me/随想/%E8%AE%B0%E5%BF%86/</link>
      <pubDate>2013-08-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自从接触了markdown之后，我就突然又爱上了写作，突然又想写点什么了，然而有时候也只是写在日记本里。每当自己翻开大学时候写的日记，总想对那个毛头小孩说句：少年，你too young，too simple。成长是一种说不出的滋味。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今天是中元节，前天妈妈跟我打电话说了，今天家里要过节，要给爷爷烧点什么。由于今天下午已经和别人约好了谈事情，我也就没有回家，错过了一次家庭聚餐。不知道从什么时候开始，我开始非常喜欢这样的聚餐，总觉得这个时候是最幸福的时刻。爷爷刚过世那几天，姨夫也每天来乡下，然后舅舅他们什么的，都会来乡下大家坐下来一起吃饭，喝个小酒。那样的日子，一个个从这个大家庭走出去成家立业的人，在人生50岁的时候又回到了大家庭，这种感觉真的太好了，这是爷爷留给我们的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;记得爷爷五七那天，大家围着那座纸房子把过旺的火焰扑灭，舅舅们正好围成一个圈，那种画面似乎会永远停留在心中，有一种说不出的滋味。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;爷爷是在4月30日的凌晨1：50过世的，我清楚的记得他弥留时候的情景，自己有时候恍惚中会在脑海中想起。当看着一个自己熟悉的人，总到生命最后的尽头，总能悟道一些以前不曾明白的道理。就像当时阿姨说的，就好像看着一艘大船慢慢沉下去，船对于我们来说，有一种特殊的意思。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在大家的话题都是弄简历，做题，看算法，找工作，比较薪酬待遇，而我似乎还没有进入这个状态，我总是在疑惑着，这一切都是为了什么？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;少年，醒醒！该搬砖了！！恩，人艰不拆，莫装逼，装逼遭雷劈，等你找不到工作了就哭去吧！！&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>新的开始</title>
      <link>http://blog.puhao.me/吐槽/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</link>
      <pubDate>2013-08-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在停止创作了N年之后，我又开始我的写作生涯了。一直想建立个自己的blog，最早想用wordpress这个框架，后来不了了之。后面自己接触到了markdown，然后觉得直接用markdown来写blog是一件多么酷的事情，然后把blog托管在github上面。&lt;br /&gt;&#xA;查了一些相关的教程，怎么利用github的page来写文章，但是感觉虽然很geek，但是很烦。终于当我看到了gor，发现这些麻烦的事情又被简化了很多，我立马就动手完成了这个blog。不过作为一个码农，是否惭愧，本来这些简化的事情就是应该是geeker干的事情，结果却沦为了一个只会使用别人工具的码农，o(╯□╰)o。&lt;br /&gt;&#xA;另外，我左手上带着一个fitbit flex，然后作为一个geeker，你懂得。&lt;br /&gt;&#xA;神马？需求变复杂了？静态页面展示不了了？别忘了我还有raspberry pi呢。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://blog.puhao.me/2013/new-born.html</link>
      <pubDate>2013-02-08 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢你使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>